<!-- <p>Developing a project</p> -->


<h1>Building your first Django Project</h1>
<p><b>Make sure you have the correct python virtual env activated.</b></p>

<p>Create your project:</p>
<pre>django-admin startproject movie_theater</pre>

<p>Run Server</p>
<pre>python manage.py runserver</pre>

<p>Your Django project should be running here http://localhost:8000</p>

<p>Create an application:</p>
<pre>python manage.py startapp movies</pre>

<h2>Django Project MVT Structure</h2>

<p>Django is based on MVT (Model-View-Template) architecture. MVT has the following parts:</p>

<p><b>Model:</b> The model is going to act as the interface of your data. It is responsible for maintaining data. It is the logical data structure behind the entire application and is represented by a database (generally relational databases such as MySql, Postgres).</p>

<p><b>View:</b> The View is the user interface — what you see in your browser when you render a website. It is represented by HTML/CSS/Javascript and Jinja files.</p>

<p><b>Template:</b> A template consists of static parts of the desired HTML output and some special syntax describing how dynamic content will be inserted.</p>

<a href="https://masteringdjango.com/django-tutorials/mastering-django-structure/">Read more</a>a

<h2>Your first view</h2>
<p>Add the following lines in movies/views.py</p>
<pre>
from django.http import HttpResponse

def index(request):
   return HttpResponse("Hello, world. You're at the movies index.")
</pre>

<p>Let’s create the movies/urls.py and add these lines:</p>
<pre>
from django.urls import path

from . import views

app_name = "movies"

urlpatterns = [
   path("", views.index, name="index"),
]
</pre>

<p>Let’s edit these lines in movie_theater/urls.py:</p>

<pre>
from django.urls import path, include

urlpatterns = [
   path('admin/', admin.site.urls),
   path('movies/', include('movies.urls', namespace='movies')),
] 
</pre>

<h2>Configure VSCodium with Django extension</h2>
<p>Add the following extensions: Python, Python Extension Pack, Django</p>
<a href="https://code.visualstudio.com/docs/python/tutorial-django">https://code.visualstudio.com/docs/python/tutorial-django</a>

<p>Close the runserver if it is open in the console.</p>
<p>Follow the website instructions to create the launch.json. You should add the following for the default program’s path:</p>
<pre>"${workspaceFolder}\\manage.py"</pre>
<p>Then edit it on the file launch.json. For example, with my configuration, it is:</p>
<pre>"${workspaceFolder}/movie_theater/manage.py"</pre>


<h1>Setting up Tools</h1>

<h2>Python Virtual Environment</h2>
<p><b>What is a virtual environment?</b></p>
<p>It is a tool that helps to keep dependencies required by different projects separate by creating isolated Python virtual environments for them.</p>

<p><b>Why do we use virtual environments?</b></p>
<ul>
  <li>Solve dependency issues: Different versions of a package for different projects.</li>
  <li>Projects self-contained and reproducible.</li>
  <li>Install packages on a machine without having admin privileges.</li>
  <li>The global site-packages/ directory (Python packages are installed here) remains clean because  you are not installing packages system-wide.</li>
</ul>

<p><b>Installing pyenv</b></p>
<p>Pyenv is a popular open-source tool for managing multiple Python installations on a single system.  It allows you to easily switch between different versions of Python, create virtual environments, and manage dependencies for Python projects. </p>
<ul>
  <li>
    <p><b>Install the prerequisites:</b></p>
    <pre>
      sudo apt update; sudo apt install build-essential libssl-dev zlib1g-dev \
libbz2-dev libreadline-dev libsqlite3-dev curl \
libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev
    </pre>
  </li>

  <li>
    <p>Run pyenv installer:</p>
    <pre>
      curl https://pyenv.run | bash
    </pre>
    <p>The installer asks to insert a few lines into ~/.bashrc (use your favorite text editor: vim):</p>

    <pre>
      export PATH="$HOME/.pyenv/bin:$PATH"
      eval "$(pyenv init --path)"
      eval "$(pyenv virtualenv-init -)"
    </pre>
    <p>Those lines will load the pyenv executable into your shell environment.</p>
  </li>
  
</ul>
<p>List the available Python versions:</p>
<pre>pyenv install –list</pre>

<p>When new Python versions are available you can refresh the list of the versions with this command: </p>
<pre>pyenv update</pre>
<p>Usually, the lastest stable version should be installed (3.11.5 when I wrote this tutorial)</p>
<pre>pyenv install 3.11.5</pre>

<p>Check Python installed versions with pyenv:</p>
<pre>pyenv versions</pre>


<p>Let’s create a folder <b>movie_theater</b> for our first project. Go inside the folder and type:</p>
<pre>pyenv local 3.11.5</pre>
<p>That creates a file .python-version in the current folder.</p>

<p>Type <b>pyenv versions</b> and you will notice that Python 3.11.5 is activated, and this version is in used because there is a file .python-version with the version described inside the file.</p>


<h2>Python Virtual Environment </h2>
<a href="https://docs.python.org/3/library/venv.html">Documentation</a>
<p>Let's run the command:</p>
<pre>python -m venv env_3.11.5</pre>

<p>This folder contains some python executable and some libraries and will be able to host independently the python package we are going to install without interfering with the python installed at the system level.</p>

<p>Delete the file .python-version, just to remove any ambiguities. And let's load the python virtual env:</p>

<p><b>Linux - Mac:</b></p>
<pre>source env_3.11.5/bin/activate</pre>

<p><b>Windows:</b></p>
<pre>env_3.11.5\Scripts\activate</pre>
<p>In case that command does not work, follow the directions <a href="https://www.stanleyulili.com/powershell/solution-to-running-scripts-is-disabled-on-this-system-error-on-powershell">here</a></p>

<p>Check the Python version:</p>
<pre>which python</pre>
<p>You will see that the python executable used is coming from the virtual env folder.</p>

<p>If you want to deactivate the python virtual env, just run:</p>
<pre>deactivate</pre>

<h2>Django Installation</h2>

<p>Go to our project folder movie_theater, make sure the virtual en is installed, and activate it.</p>

<p>Let’s create a folder: <b>requirements_env</b>. Inside this folder, we are going to create two files: <b>main.in</b> and <b>dev.in</b></p>

<p>These two files will list the package that we are going to need for our project. We can separate the package we need between production and development. We are not going to put our project into a server for production use (under a nginx server, a web server like gunicorn or uvicorn, systemd for a system services manager, logging backup…), but we can separate the package so you know how to do it.</p>

<p>You have more documentation <a href="https://github.com/jazzband/pip-tools#workflow-for-layered-requirements">here</a>: 

<p>In the file main.in, we can add the django package:</p>
<p>django==4.2</p>

<p>In the file dev.in, let's add:</p>
<p>-c main.txt</p>  

<p>nodeenv</p>

<p>For django, target a version because for each version, the django team adds new features, and some settings could change, but they do the best to keep everything working when you move to a higher version. For other package, you do not need to target a specific version, but when you are ready to move on production, it is better to freeze the versions of all the packages you have selected (no need to specify the versions of the dependencies).</p>
<p>nodeenv will be used later in the course when we will need to compile some javascript libraries.</p>

<p>Let's build the packages:</p>
<pre>
  pip install --upgrade pip-tools pip setuptools wheel
  pip-compile --upgrade --generate-hashes --output-file requirements_env/main.txt requirements_env/main.in
  pip-compile --upgrade --generate-hashes --output-file requirements_env/dev.txt requirements_env/dev.in  
</pre>

<p>Installing the packages:</p>
<pre>
# production
pip-sync requirements_env/main.txt

#dev
pip-sync requirements_env/main.txt requirements_env/dev.txt
</pre>

<p>You can check the packages that have been installed running the following command:</p>
<pre>pip list</pre>

<h2>Editor</h2>

<ul>
  <li>VSCodium:</li>
    <ul>
      <li>Enable autosave to avoid any dramatic situation: Files => Auto Save</li>
      <li>Install the extensions: Python extension pack</li>
    </ul>
  <li>Any simple text editor is totally fine. In python you can debug with import pdb;pdb.set_trace(), then write “interact” if you want to be able to write multiple line statements.</li>
  
</ul>
<h1>Password Management</h1>

<p>It is important to securely store, generate and manage passwords.</p>
<p>There are many online password management applications that provide convenience. However, there could be some disadvantages:</p>
<ul>
  <li>Dependency on the Internet: These applications require Internet access. If, for some reason, your Internet is down, you cannot access your passwords.</li>
  <li>Security Risks: Your passwords can be accessed by a third-party service.</li>
  <li>Data Breaches: Unauthorized parties access to the sensitive data in the servers.</li>
  <li>Cost: There are some applications free, but those that offer robust security could be expensive.</li>
</ul>

<p>Instead of using an online password management application, we can use a tool that allows us to store an encrypted file with the password we need in a desired location.</p>

<p><b>KeePassXC</b> is a secure and open-sources password manager that can help to store passwords.</p>

<h3>KeePassXC</h3>
<ul>
  <li>Download <a href="https://keepassxc.org/">KeePassXC</a></li>
  <li>Go to the folder where KeePassXC was downloaded, right-click on the icon, click on Permission, and select the checkbox "Allow executing file as program". Close the properties window. </li>
  <li>Now, you can execute KeePassXC. Double-click on the icon.</li>
  <li>You can create a new database for your passwords, adjust the database encryption, add your passwords, and save the database (file) with your passwords.</li>
</ul>
<p>I suggest that you store the KeePassXC database in Google Drive and have your Google Drive mounted on your computer as a driver.</p>

<h1>Mount Google Drive</h1>
<p><b>Linux:</b></p>
<p>On Linux Mint (or a Debian derivative), you can go to your System Settings -> Online Accounts -> Google, and enter your credentials. Now, you should have Google Drive mounted as a drive in your computer. When selecting the Google product to mount, you must choose only 'files', unselect the other options.</p>
</p>
<p><b>Windows and MacOS: Download Google Driver Client <a href="https://www.google.com/drive/download/">here</a></b></p>

<p>You will see Google Drive mounted on your computer as another drive.</p>

<p>Path Google Drive mounted: /run/user/your_user_session_id/gvfs/your_google_drive/</p>

<p>Check your session id: loginctl list-sessions</p>


<p>Possible issue when adding Google credentials: Password does not match the original (keyring)</p>
<p><b>Solution:</b></p>
<p>Go to Passwords and Keys in your computer. Right click on Login -> Delete</p>

  
<h1>Pre-work</h1>

<p>SoftDev pre-work aims to learn/review the basics of Python, the backend programming language that will be used in this course. While some students have already worked with Python, it is a new language for others. The programming skills learned using Java last year will help to pick Python quickly because Python is a dynamic language, and the syntax is easier than Java.</p>

<p>Please go to the Homework webpage to find the directions to complete your pre-work. </p>
